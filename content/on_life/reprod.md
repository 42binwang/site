! Reproducibility 可复现性

# Reproducibility 可复现性

这篇文章聊一下“可复现性”这个问题。这个词通常用来描述科研成果，我这次从工程角度来聊一聊。

## LMD

先从LMD开始。

学过电路的同学可能还记得“集总电路(Lumped Circuit)”。在经典的MIT 6002课中，教授不断强调的就是“集总事物守则”(Lumped Matter Discipline)。

从物理的角度出发，我们可以用麦克斯韦方程组描述一切电子电气系统。在工程实践中我们却不能这么做：因为用计算机求解这样一个系统的时间复杂度实在是太高了。换言之，如果大家都用麦克斯韦方程组设计电路，结果就是什么也设计不出来。

比如电流流经一个环路，会在环路周围产生磁场；如果是交变电流则会产生交变磁场，最终会有一部分能量以电磁波的形式向外传播。而一个简单的电子系统，比如一台手机，环路数量在亿级别，工作频率也不低，环路之间自然也会互相以电磁波的形式传递能量。要对这样一个电磁系统建模仿真，所需的数值计算量大概是10后面加40个零，当然是不实际的。

但是人类最终还是造出了手机。这主要就是因为工程师们坚持了“集总事物守则”。

## 消除相互影响

在上一个例子中，手机中的所有元件、所有环路之间都会相互影响。如果不考虑环路的互相影响，把元件都看成理想的个体呢？

以电阻为例，我们可以规定电阻必须遵守欧姆定律，即 I = U/R 。实际通过电阻的电流肯定要受周围物理环境的影响，但我们可以忽略这些影响，强行要求遵守欧姆定律。

然后我们再强行规定，环路必须遵守基尔霍夫电压定律(KVL)，即任何环路电压之和为零。这忽略了实际电路中的互感现象，即环路与环路之间的互相影响。

这样问题的复杂度就大幅度降低了：元件只和其周边的元件发生作用，而不是像原来那样和所有其他元件（以及外部环境）都发生作用。作用的种类也大大减少了。然后我们就可以在草稿纸上（而不是天河一号），利用节点法求解一般的电子电路了。

## 继续消除影响

如上所述，要高效地解决工程问题，就要尽量消除元件之间的相互影响。相互影响的因素越少，达成目标的手段就越简单，系统就越容易设计。其实生活也是这样的，大家都希望自己的各种社会关系、活动之间不要相互影响，这样能活得轻松些。

继续以电路为例。上面的例子要求电阻必须遵守欧姆定律，所以电阻厂家就专门生产严格符合欧姆定律的电阻；上面的例子要求环路之间不能互相影响，所以我们经常在电路设计中增加屏蔽和缓冲。总而言之，电路和电路元件的特性越确定，工程师的工作就越轻松。

如果要再进一步提高确定性呢？于是人们定义了一类比较特殊的电路，这些电路几乎总是工作在饱和状态，用高低电平表示和传递信息，称为数字逻辑电路。它们的行为几乎完全不受环境干扰，而它们的工作规律也从基尔霍夫电路定律（信号可以任意传递）简化成了逻辑运算（信号只能朝某个方向传递）。

在线性（模拟）电路中，我们虽然强行规定环路之间不会相互影响，但这种影响肯定是存在的，区别只是程度高低而已；而元件本身的特性也总是很难完美。到了数字逻辑电路中，这种影响就几乎可以忽略不计了，元件特性也非常容易保证完美，这就是为什么数字逻辑电路的规模可以比模拟电路的规模大成千上万倍——因为元件和环路之间的影响足够小。

正是因为元件确定性高，互相影响小，一个大的设计总是可以拆分成许多个小的设计，其中每个小设计的特性都是确定且无须怀疑的。在模拟设计中，要保证1000个电阻的误差在0.01%以内是一件非常奢侈、只有高端设计才会考虑的事情；而在数字设计中，由1,000,000个逻辑门组成的、连续工作10年不出错的芯片，比快递费还要便宜得多。

## 可复现性

我把这种特性概括成系统的“可复现性”。这个性质可以这么理解：

- 一个系统的基本组成部分的特性越确定，则复用这些基本组成部分、实现一个系统的难度（成本）就越低。

>我实在是想不到什么好的表达方式了。直接看下面的例子吧。

比如我们要写一份文档，考虑下面两种途径：

1. 购买计算机 -> 安装Windows 7 -> 安装Office -> 开始写文档
2. 购买计算机 -> 安装Ubuntu -> 安装Open/LibreOffice -> 开始写文档

大家通常会选择第一种方法，因为第一种方法的可复现性最高：只要把DVD放进光驱，基本上99%的电脑都可以一次性成功。如果选择第二种途径，你会先遇到一些驱动问题，然后遇到软件兼容性问题，最后还可能需要在终端敲命令。而且每一台电脑上的安装过程可能还不一样，这边可以那边未必就行。这都是令人难以接受的成本。如果是比写文档稍微复杂一点的事情，绝大多数人拿Linux是毫无办法的。

Windows的高可复现性，源自微软持续不断的投入，当然也给微软带来了持续不断的收入。大家需要的正是这种千篇一律：只有一成不变的东西，使用和维护的成本才会低。

不过有些事情大家更乐于在Linux上做，比如数不胜数的开源软件。开源的好处就是：对于那些微软并没有花时间解决的问题，开源开发流程的可复现性要高得多。对于开发者来说，在Linux上开发遇到的任何问题，只要花一些时间，都是**可以解决的**；而在Windows上遇到的同类问题，并没有这个保证。

但我们也可以看到，越来越多的开源软件被推荐在Ubuntu或者CentOS上运行(比如TensorFlow, Docker等)，因为这些系统的保有量大，版本稳定。对这些软件而言，操作系统就是它们的基本组成元件，这个元件的特性自然是越确定越好的。

## 软件领域

一个软件系统的基本组成元件是操作系统、语言（编译器或者解释器）和库。正如电子设计要假设元件是理想且确定的，软件设计也要假设操作系统、语言和库是理想且确定的。如果malloc()返回的不是指针，如果for循环的执行顺序发生改变，如果函数的入口名称改动了一个字，软件都是无法正常工作的。

举软件的例子，是因为这方面我比较熟悉，而且互联网软件最近10年的发展也比较好地反映出了大家对高可复现性的要求。

简单来说，程序员和网管都希望只有一种操作系统、一种语言、一个代码库（这样就很容易保证高可复现性，赚钱也就很轻松啦）。然而现实是我们需要不同的语言，不同的操作系统，浩如繁星的库。怎么办呢？你可能会说没有好的解决方法，而Google作为目前世界第一的软件公司，给出的答案是这样：

- 全都用Linux
- 语言只准用C++ Java Python Go
- 语言之间的数据交换，全都用protobuf
- 不准用动态库，全部静态链接
- 编译公司所有软件所需的代码都放在一个全局代码库中，要啥有啥
- 所有软件的运行环境相互隔离（Google 15年前就开始应用容器技术了），互相无法影响（相当于每个软件眼中的系统都一样）

这样做当然是有代价的。比如静态链接会极大地增加编译时间，需要靠分布式系统加速编译；全局代码库非常庞大，IOPS极高，需要建设成分布式系统；等等。但这也带来了很多好处，比如静态编译的程序不需要目标系统安装动态运行库（从而也就不会因为缺少运行库而浪费大量时间），而全局代码库则避免大家在不同项目之间来回黏贴代码。

因此一个Google程序员需要掌握的基本组成元件，不仅数量上很少，而且确定性也非常高，在设计功能强大的系统时就比其他公司的程序员轻松得多。可以说这一系列设施使得Google在软件工程的沙场上战无不胜。

## Q&A

运用同样的逻辑，我们可以解释软硬件工程领域的许多现象。

- 问：为什么C语言流行？

  答：在X86上是这样，在ARM上也是这样（消除底层架构的影响）

- 问：为什么PHP流行？

  答：（最早的时候）直接嵌入在HTML里面，HTML是这样，PHP出来也是这样

- 问：为什么Java流行？

  答：在Windows上是这样，在Linux上也是这样（消除操作系统的影响）。招一个程序员是这样，招100个程序员也是这样（消除人事因素的影响）

- 问：为什么云服务器流行（即便比自己维护服务器贵）？

  答：一台是这样，20台也是这样

- 问：为什么容器技术(Docker, Kubernetes)流行？

  答：在本机是这样，到了云端也是这样（消除有和没有运维团队的区别）

- 问：为什么STM32流行？

  答：毕业论文是这样，上班也是这样

- 问：为什么Web应用要连数据库，而不写本地文件？

  答：一个实例是这样，20个实例也是这样（消除单进程和分布式系统的区别）

可以说，工程领域大量的工作都是在解决可复现性问题。因为我们是人类，我们总是希望用尽量少的脑力解决尽量多的问题，而可复现性可以帮助我们做到这一点。

## 展望未来

历史告诉我们：之所以不同地区的人讲不同的语言，仅仅是历史原因。为了提高协作的效率，世界上的语言数量越来越少，而说主要语言的人口则越来越多，这个趋势一刻也没有停止过。正如上一节末尾谈到的：这是人的本性。

展望未来，我们应该会使用几种固定的操作系统（很可能是云上运行的某种极简系统环境，参考CoreOS）来运行软件，几种固定的语言（很可能是Python和JS）来设计软件，正如我们今天会用几种固定的方法和工具来设计电子系统一样。
